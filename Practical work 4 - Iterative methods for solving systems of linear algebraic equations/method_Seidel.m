# A - матрица системы. (Предполагаем, что диагональные элементы не 0
# esp - епсилон (точность).

# Функция возвращает:
#   root = решение системы линейных алгебраический уравнений.
#   error_p2_norm - ошибка в решение от номера итерации, вычисленная по p2 матричной норме.                     ??????????????????????????????????
#   error_Frobenius_norm - ошибка в решение от номера итерации, вычисленная по матричной норме Фробениуса.      ??????????????????????????????????
#   nevyazka - невязка в решение от номера итерации, вычисленная с помощью максимальной или бесконечной нормы вектора.

function [root, error_p2_norm, error_Frobenius_norm, nevyazka] = method_Seidel(A, esp)
  
  disp("\nМетод Зейделя")
  
  b=zeros(numel(A(1,:)), 1) + 1; # numel(A(1,:)) - вернет порядок матрицы A. (Матрица A - квадратная).
  B = inv(diag(diag(A)))*(diag(diag(A))-A); # Бездиагональная матрица, элементы которой с минусом и в каждой строке делятся на соответсвующий диагональный элемент матрицы A.
  
  if (matrix_p2_norm(B) < 1) & (matrix_Frobenius_norm(B) < 1) # Достаточно проверить одну любую норму, я проверяю две.
    disp("Норма матрицы B < 1, тогда решение системы существует и единственно.\n")
  else
    disp("Норма матрицы B >= 1, нужна другая матрица.\n")    
    ### ЧТО ТОГДА???????? РЕШЕНИЕ НЕ ЕДИНСТВЕННО ИЛИ ЕГО НЕТ ИЛИ НЕЛЬЗЯ ВЫЧИСЛИТЬ ДАННЫМ СПОСОБОМ
  endif
  
  B1=tril(B); # Бездиагональная нижняя треугольная матрица, элементы которой с минусом и в каждой строке делятся на соответсвующий диагональный элемент матрицы A.
  B2=triu(B); # Бездиагональная верхняя треугольная матрица, элементы которой с минусом и в каждой строке делятся на соответсвующий диагональный элемент матрицы A.
  c=inv(diag(diag(A)))*b;
  
  X_k = zeros (numel(A(1,:)),1); # Вектор-столбец неизвестных на k-ой итерации.
  X_Kplus1 = zeros (numel(A(1,:)),1); # Вектор-столбец неизвестных на (k+1)-ой итерации.
  
  k=0; # Количество итераций.

  while (1)
    
    for i = 1:numel(A(1,:)) # numel(A(1,:)) - вернет размерность матрицы.
      X_Kplus1(i) = B1(i,:)*X_Kplus1+B2(i,:)*X_k+c(i);            
    endfor
    k=k+1;
    
    error_p2_norm(k) = (matrix_p2_norm(B2)/(1-matrix_p2_norm(B)))*vector_p_infinity_norm(X_Kplus1-X_k);
    error_Frobenius_norm(k) = (matrix_Frobenius_norm(B2)/(1-matrix_Frobenius_norm(B)))*vector_p_infinity_norm(X_Kplus1-X_k);
    nevyazka(k) = matrix_p2_norm(A*X_Kplus1-b);    
    
    if (esp >= vector_p_infinity_norm(X_Kplus1-X_k))
      break
    endif
    
    X_k=X_Kplus1;
    
  endwhile
  
  root = X_Kplus1;
  
  endfunction