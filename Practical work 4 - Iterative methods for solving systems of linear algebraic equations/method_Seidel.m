# A - матрица системы. (Предполагаем, что диагональные элементы не 0
# esp - епсилон (точность).

# Функция возвращает:
#   root = решение системы линейных алгебраических уравнений.
#   error - ошибка в решении от номера итерации, вычисленная по p2 векторной норме и матричной норме Фробениуса.
#   nevyazka - невязка в решение от номера итерации, вычисленная с помощью максимальной или бесконечной нормы вектора.
#   root_changes - матрица, хранящая корни полученные на каждом шаге итерации.

function [root, error, nevyazka, root_changes] = method_Seidel(A, esp)
  
  disp("\nМетод Зейделя")
  
  b = zeros(numel(A(1,:)), 1) + 1; # numel(A(1,:)) - вернет порядок матрицы A. (Матрица A - квадратная).
  B = inv(diag(diag(A)))*(diag(diag(A))-A); # Бездиагональная матрица, элементы которой с минусом и в каждой строке делятся на соответсвующий диагональный элемент матрицы A.
  
  if (matrix_Frobenius_norm(B) < 1)
    disp("Норма матрицы B < 1, тогда решение системы существует и единственно.\n")
  else
    disp("Норма матрицы B >= 1, cходимость не гарантирована.\n")    
    # Сходимость не гарантирована. (Кажется, там было не гарантировано).
  endif
  
  B1=tril(B); # Бездиагональная нижняя треугольная матрица, элементы которой с минусом и в каждой строке делятся на соответсвующий диагональный элемент матрицы A.
  B2=triu(B); # Бездиагональная верхняя треугольная матрица, элементы которой с минусом и в каждой строке делятся на соответсвующий диагональный элемент матрицы A.
  c=inv(diag(diag(A)))*b;
  
  X_k = zeros (numel(A(1,:)),1); # Вектор-столбец неизвестных на k-ой итерации.
  X_Kplus1 = zeros (numel(A(1,:)),1); # Вектор-столбец неизвестных на (k+1)-ой итерации.
  root_changes = X_k'; # Вектор-столбец неизвестных на k-ой итерации транспонируем и получаем вектор-строку.
  
  k=0; # Количество итераций.

  while (1)
    
    for i = 1:numel(A(1,:)) # numel(A(1,:)) - вернет размерность матрицы.
      X_Kplus1(i) = B1(i,:)*X_Kplus1+B2(i,:)*X_k+c(i);            
    endfor
    k=k+1;
    
    error(k) = (matrix_Frobenius_norm(B2)/(1-matrix_Frobenius_norm(B)))*vector_p2_norm(X_Kplus1-X_k);
    nevyazka(k) = matrix_p2_norm(A*X_Kplus1-b);    
    
    for i = 1:numel(root_changes(1,:))
      root_changes(k+1, i) = X_Kplus1(i);
    endfor
    
    if (esp >= vector_p2_norm(X_Kplus1-X_k))
      break
    endif
    
    X_k=X_Kplus1;
    
  endwhile

  root = X_Kplus1;
  
  endfunction